#include <sys/wait.h> // Potrzebne do waitpid

// ... (reszta include i definicji bez zmian)

void* do_work(void* p)
{
    dron* args = (dron*)p;

    // --- ETAP 1: Wydobycie ---
    if (sem_wait(args->semaphore))
        ERR("sem_wait");

    ms_sleep(args->sleep_time);
    printf("DRONE <%d>: FINISHED MINING\n", args->id);

    if (sem_post(args->semaphore))
        ERR("sem_post");

    // --- ETAP 2: Synchronizacja i Analizator ---
    int res = pthread_barrier_wait(args->barrier);
    if (res == PTHREAD_BARRIER_SERIAL_THREAD)
    {
        // Tylko jeden wątek wysyła sygnał i wypisuje komunikat
        printf("ALL DRONES FINISHED MINING!\n");
        kill(args->analyzer_pid, SIGUSR1);
        
        // Czekanie, aż proces analizatora skończy pracę (wyjdzie z exit)
        if (waitpid(args->analyzer_pid, NULL, 0) < 0)
            ERR("waitpid");
    }
    
    // Druga bariera zapewnia, że wszystkie drony ruszą dalej dopiero
    // gdy waitpid w wątku SERIAL zakończy się sukcesem.
    pthread_barrier_wait(args->barrier);

    return NULL;
}

int main(int argc, char* argv[])
{
    // ... (walidacja argumentów N)

    /* Blokujemy SIGUSR1 - maska zostanie odziedziczona przez proces potomny i wątki */
    sigset_t mask;
    sigemptyset(&mask);
    sigaddset(&mask, SIGUSR1);
    if (sigprocmask(SIG_BLOCK, &mask, NULL))
        ERR("sigprocmask");

    pid_t analyzer_pid = fork();
    if (analyzer_pid < 0) ERR("fork");

    if (analyzer_pid == 0)
    {
        /* PROCES ANALIZATORA */
        int sig;
        // Czeka na sygnał SIGUSR1
        if (sigwait(&mask, &sig) != 0) ERR("sigwait");
        
        printf("ANALYZER: STARTED\n");
        ms_sleep(500);
        printf("ANALYZER: FINISHED\n");
        
        // Zgodnie z treścią: "i kończy się"
        exit(EXIT_SUCCESS);
    }

    /* PROCES RODZICA (DRONY) */
    dron* tab = malloc(N * sizeof(dron));
    sem_t semaphore;
    sem_init(&semaphore, 0, FS_NUM);

    pthread_barrier_t barrier;
    pthread_barrier_init(&barrier, NULL, N);

    for (int i = 0; i < N; i++)
    {
        tab[i].id = i;
        tab[i].semaphore = &semaphore;
        tab[i].sleep_time = 200;
        tab[i].barrier = &barrier;
        tab[i].analyzer_pid = analyzer_pid;

        if (pthread_create(&tab[i].tid, NULL, do_work, &tab[i]))
            ERR("pthread_create");
    }

    for (int i = 0; i < N; i++)
        pthread_join(tab[i].tid, NULL);

    /* SPRZĄTANIE */
    // Nie musimy już robić kill(analyzer_pid, SIGTERM), 
    // bo analizator sam się zakończył, a wątek go "odebrał" przez waitpid.

    sem_destroy(&semaphore);
    pthread_barrier_destroy(&barrier);
    free(tab);

    return EXIT_SUCCESS;
}
