#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <signal.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <string.h>
#include <time.h>

// Flagi dla dziecka
volatile sig_atomic_t child_running = 0;
volatile sig_atomic_t child_terminate = 0;
int counter = 0;

// Flagi dla rodzica
volatile sig_atomic_t parent_switch = 0;
volatile sig_atomic_t parent_terminate = 0;

// Obsługa sygnałów dla dziecka
void child_handler(int sig) {
    if (sig == SIGUSR1) {
        child_running = 1;
    } else if (sig == SIGUSR2) {
        child_running = 0;
    } else if (sig == SIGINT) {
        child_terminate = 1;
    }
}

// Obsługa sygnałów dla rodzica
void parent_handler(int sig) {
    if (sig == SIGUSR1) {
        parent_switch = 1;
    } else if (sig == SIGINT) {
        parent_terminate = 1;
    }
}

void child_work(int index) {
    printf("Dziecko PID: %d, Indeks: %d rozpoczyna pracę.\n", getpid(), index);
    
    // Konfiguracja sygnałów dla dziecka
    struct sigaction sa;
    sa.sa_handler = child_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sigaction(SIGUSR1, &sa, NULL);
    sigaction(SIGUSR2, &sa, NULL);
    sigaction(SIGINT, &sa, NULL);

    srand(time(NULL) ^ (getpid() << 16));

    while (!child_terminate) {
        if (child_running) {
            // Losowy czas 100-200ms (100000 - 200000 us)
            usleep((rand() % 101 + 100) * 1000);
            counter++;
            printf("%d: %d\n", getpid(), counter);
        } else {
            // Oczekiwanie na sygnał, gdy dziecko nie pracuje
            pause();
        }
    }

    // Zapis licznika do pliku {PID}.txt przy użyciu systemowych wywołań
    char filename[32];
    char buffer[64];
    snprintf(filename, sizeof(filename), "%d.txt", getpid());
    int fd = open(filename, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd != -1) {
        int len = snprintf(buffer, sizeof(buffer), "%d\n", counter);
        write(fd, buffer, len);
        close(fd);
    }

    exit(0);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Użycie: %s <N>\n", argv[0]);
        return 1;
    }

    int N = atoi(argv[1]);
    if (N <= 0) return 1;

    pid_t *children = malloc(N * sizeof(pid_t));
    int current_child_idx = 0;

    // Konfiguracja sygnałów dla rodzica
    struct sigaction sa;
    sa.sa_handler = parent_handler;
    sigemptyset(&sa.sa_mask);
    sa.sa_flags = 0;
    sigaction(SIGUSR1, &sa, NULL);
    sigaction(SIGINT, &sa, NULL);

    // Tworzenie dzieci
    for (int i = 0; i < N; i++) {
        pid_t pid = fork();
        if (pid == 0) {
            child_work(i);
        } else {
            children[i] = pid;
        }
    }

    // Zlecenie pracy pierwszemu dziecku
    sleep(1); // Krótka pauza na inicjalizację dzieci
    kill(children[0], SIGUSR1);

    while (!parent_terminate) {
        pause(); // Czekaj na sygnały

        if (parent_switch && !parent_terminate) {
            // Zatrzymaj obecne dziecko
            kill(children[current_child_idx], SIGUSR2);
            
            // Przejdź do następnego (cyklicznie)
            current_child_idx = (current_child_idx + 1) % N;
            
            // Uruchom następne dziecko
            kill(children[current_child_idx], SIGUSR1);
            
            parent_switch = 0;
        }
    }

    // Obsługa zakończenia (SIGINT)
    printf("\nZamykanie klastra...\n");
    for (int i = 0; i < N; i++) {
        kill(children[i], SIGINT);
    }

    // Czekanie na zakończenie wszystkich dzieci
    for (int i = 0; i < N; i++) {
        waitpid(children[i], NULL, 0);
    }

    free(children);
    printf("Rodzic kończy pracę.\n");
    return 0;
}
