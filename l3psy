#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include <time.h>
#include <signal.h>
#include <stdbool.h>

// Struktura przechowująca dane wspólne dla całego wyścigu
typedef struct {
    int n;                  // długość toru
    int m;                  // liczba psów
    int *track;             // tablica toru
    pthread_mutex_t *track_mutexes; // tablica mutexów dla każdego pola
    int finish_count;       // licznik psów na metcie
    pthread_mutex_t finish_mutex;   // mutex dla licznika i tablicy zwycięzców
    int *winners;           // tablica przechowująca 3 pierwsze psy
    pthread_t *dog_threads; // tablica identyfikatorów wątków
    bool interrupted;       // flaga przerwania przez SIGINT
} RaceData;

// Struktura przekazywana do konkretnego wątku psa
typedef struct {
    int id;
    RaceData *race;
} DogArgs;

// Funkcja pomocnicza do usypiania w milisekundach
void msleep(int ms) {
    struct timespec ts;
    ts.tv_sec = ms / 1000;
    ts.tv_nsec = (ms % 1000) * 1000000L;
    nanosleep(&ts, NULL);
}

// Funkcja wątku psa
void* dog_routine(void* arg) {
    DogArgs *args = (DogArgs*)arg;
    RaceData *race = args->race;
    int id = args->id;
    int current_pos = 0;
    int direction = 1; // 1: w prawo, -1: w lewo

    // Wejście na tor (pozycja 0)
    pthread_mutex_lock(&race->track_mutexes[0]);
    race->track[0]++;
    pthread_mutex_unlock(&race->track_mutexes[0]);
    printf("Pies %d: Startuję z pozycji 0\n", id);

    while (current_pos < race->n - 1) {
        msleep(200 + rand() % (1520 - 200 + 1));

        int dist = 1 + rand() % 5;
        int next_pos = current_pos + (direction * dist);

        // Obsługa wyjścia poza zakres (odbicie)
        if (next_pos >= race->n) {
            next_pos = race->n - 1;
            direction = -1;
        } else if (next_pos < 0) {
            next_pos = 0;
            direction = 1;
        }

        // Sprawdzenie kolizji
        pthread_mutex_lock(&race->track_mutexes[next_pos]);
        if (race->track[next_pos] > 0 && next_pos != current_pos) {
            printf("Pies %d: waf waf waf (pozycja %d zajęta)\n", id, next_pos);
            pthread_mutex_unlock(&race->track_mutexes[next_pos]);
        } else {
            // Aktualizacja pozycji
            pthread_mutex_lock(&race->track_mutexes[current_pos]);
            race->track[current_pos]--;
            pthread_mutex_unlock(&race->track_mutexes[current_pos]);

            race->track[next_pos]++;
            pthread_mutex_unlock(&race->track_mutexes[next_pos]);

            current_pos = next_pos;
            printf("Pies %d: nowa pozycja %d\n", id, current_pos);

            // Sprawdzenie czy meta
            if (current_pos == race->n - 1) {
                pthread_mutex_lock(&race->finish_mutex);
                race->finish_count++;
                int place = race->finish_count;
                if (place <= 3) {
                    race->winners[place - 1] = id;
                }
                printf("Pies %d: DOTARŁ DO METY na miejscu %d!\n", id, place);
                pthread_mutex_unlock(&race->finish_mutex);
                break;
            }
        }
    }

    free(args);
    return NULL;
}

// Wątek obsługujący sygnał SIGINT
void* signal_handler_routine(void* arg) {
    RaceData *race = (RaceData*)arg;
    sigset_t set;
    sigemptyset(&set);
    sigaddset(&set, SIGINT);
    int sig;

    sigwait(&set, &sig); // Czeka na SIGINT

    printf("\n[Otrzymano SIGINT] Przerywanie zawodów...\n");
    race->interrupted = true;

    for (int i = 0; i < race->m; i++) {
        pthread_cancel(race->dog_threads[i]);
    }
    return NULL;
}

int main(int argc, char *argv[]) {
    if (argc < 3) {
        fprintf(stderr, "Użycie: %s <długość n > 20> <liczba psów m > 2>\n", argv[0]);
        return 1;
    }

    int n = atoi(argv[1]);
    int m = atoi(argv[2]);

    if (n <= 20 || m <= 2) {
        fprintf(stderr, "Błędne parametry: n musi być > 20, m musi być > 2\n");
        return 1;
    }

    srand(time(NULL));

    // Blokowanie SIGINT w wątku głównym i nowo tworzonych wątkach
    sigset_t set;
    sigemptyset(&set);
    sigaddset(&set, SIGINT);
    pthread_sigmask(SIG_BLOCK, &set, NULL);

    // Inicjalizacja danych wyścigu
    RaceData race;
    race.n = n;
    race.m = m;
    race.track = calloc(n, sizeof(int));
    race.track_mutexes = malloc(n * sizeof(pthread_mutex_t));
    race.winners = malloc(3 * sizeof(int));
    race.dog_threads = malloc(m * sizeof(pthread_t));
    race.finish_count = 0;
    race.interrupted = false;
    pthread_mutex_init(&race.finish_mutex, NULL);

    for (int i = 0; i < n; i++) {
        pthread_mutex_init(&race.track_mutexes[i], NULL);
    }

    // Wątek sygnałowy
    pthread_t sig_thread;
    pthread_create(&sig_thread, NULL, signal_handler_routine, &race);

    // Tworzenie wątków psów
    for (int i = 0; i < m; i++) {
        DogArgs *args = malloc(sizeof(DogArgs));
        args->id = i + 1;
        args->race = &race;
        pthread_create(&race.dog_threads[i], NULL, dog_routine, args);
    }

    // Pętla główna monitorująca
    while (1) {
        msleep(1000);

        pthread_mutex_lock(&race.finish_mutex);
        bool all_finished = (race.finish_count == m);
        bool interrupted = race.interrupted;
        pthread_mutex_unlock(&race.finish_mutex);

        if (all_finished || interrupted) break;

        printf("Stan toru: [");
        for (int i = 0; i < n; i++) {
            pthread_mutex_lock(&race.track_mutexes[i]);
            printf("%d", race.track[i]);
            pthread_mutex_unlock(&race.track_mutexes[i]);
            if (i < n - 1) printf("|");
        }
        printf("]\n");
    }

    // Sprzątanie po wątkach
    for (int i = 0; i < m; i++) {
        pthread_join(race.dog_threads[i], NULL);
    }

    if (race.interrupted) {
        printf("Zawody zostały przerwane przez użytkownika.\n");
    } else {
        printf("\nWYŚCIG ZAKOŃCZONY!\nPodium:\n");
        for (int i = 0; i < 3; i++) {
            printf("%d. miejsce: Pies nr %d\n", i + 1, race.winners[i]);
        }
    }

    // Zwalnianie zasobów
    for (int i = 0; i < n; i++) pthread_mutex_destroy(&race.track_mutexes[i]);
    pthread_mutex_destroy(&race.finish_mutex);
    free(race.track);
    free(race.track_mutexes);
    free(race.winners);
    free(race.dog_threads);

    return 0;
}
